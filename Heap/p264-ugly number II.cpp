/*
 * Naive Solution:
 * Iterate through all numbers and check if it is composed with the numbers that have already existed\ 
 * if not then its prime factors include elements other than 2, 3, 5
 * 
 * Time complexity: O(Nlogn), N is the total number it iterates through (most numbers in N are not ugly number), n is the input n
 *
 * Priority Queue (Solution 2):
 * Since most numbers are not ugly number, so instead of iterating and identifying whether it is or not, we can try to directly generate the next ugly number in the order
 * Notice that ugly numbers can only be generated by an ugly number multiplying 2 or 3 or 5\ 
 * Therefore, the next ugly number must be in the product of all ugly numbers we have now with 2 or 3 or 5
 * And we can then use heap structure to obtain it (the least one)
 * After popping it out, we push its product with 2, 3, 5 into the heap as well, and then find the next ugly number by top()
 * By repeating so, we will reach the answer after popping out n-1 ugly numbers
 *
 * Time complexity: O(3 * n * logn) = O(nlogn)
 *
 *
 * DP (Solution 3):
 * When it comes to using the past to generate the future, we may think about DP
 * As mentioned above, the next ugly number comes from 2, 3, 5 multiply the ugly numbers we have now
 * However, we now focus on 2, 3, 5 rather than the ugly number added in the array\ 
 * that is, we don't need to multiply them with 2, 3, 5 once they are put into the array
 * Insted, starting from the least (i) ugly number we have, we multiply 2, 3, 5 with it and pick the least one\ 
 * Then, 2, 3, 5 which generate the least one will multiply with the second least (i+1) ugly number in the next round
 * After n-1 round, we will find out the n-th ugly number
 *
 * Time complexity: O(n)
 *
 * */
#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <algorithm>
using namespace std;

int Solution(int n){
	if(n == 1) return 1;
	set<int> ug;
	int num;
	ug.insert(1);
	n--;
	for(num=2; n > 0; num++){
		if(num%2 == 0 && ug.find(num/2) != ug.end()){
			ug.insert(num);
			n--;
		}else if(num%3 == 0 && ug.find(num/3) != ug.end()){
			ug.insert(num);
			n--;
		}else if(num%5 == 0 && ug.find(num/5) != ug.end()){
			ug.insert(num);
			n--;
		}
	}
	return num-1;
}

int Solution2(int n){
	priority_queue<int, vector<int>, greater<int> > pq;
	pq.push(1);
	int base[3] = {2, 3, 5};
	while(n > 1){
		int tmp = pq.top();
		while(!pq.empty() && pq.top() == tmp) pq.pop();
		int limit = 2147483647/tmp;//avoiding overflow
		for(auto &b: base)
			if(b <= limit)
				pq.push(tmp * b);
		n--;
	}
	return pq.top();
}

int Solution3(int n){
	if(n == 1) return n;
	n -= 1;
	vector<int> ug;
	ug.push_back(1);
	int i2 = 0, i3 = 0, i5 = 0;
	while(n--){
		int cur = min(ug[i2]*2, min(ug[i3]*3, ug[i5]*5));
		if(ug[i2]*2 == cur) i2++;
		if(ug[i3]*3 == cur) i3++;
		if(ug[i5]*5 == cur) i5++;
		ug.push_back(cur);
	}
	return ug.back();
}

int main(){
	int n;
	cin >> n;
	cout << Solution3(n) << endl;
	cout << Solution2(n) << endl;
	cout << Solution(n) << endl;
}
